==============
  MegaBot-NG
==============

------------------------
1. Building instructions
------------------------
    Building MegaBot-NG requires that Qt development libraries are installed. It only
    uses a small part of the QT modules (QtCore, QtXml and QtNetwork).
    Qt version 4.6 (or higher) is required.

    A recent version of the QXMPP library is bundled with MegaBot-NG and
    will be built as a dependency.

    To build simply run

	 qmake && make

   in the top directory (containing the file 'main.pro')

------------------------
2. Initial configuration
------------------------
    The bot will read/write its configuration options from

	$(HOME)/.config/[LtK]Studios/MegaBot.conf

    where $(HOME) expands to the home directory of the system user that started
    the MegaBot binary. Here is an example config file ready for copy-past-edit:

    ------------------>>> CUT HERE <<<--------------------

    [General]
    basePath=$(INSTALLPATH)

    [Servers]
    size=1
    1\host=example.com
    1\domain=example.com
    1\account=example
    1\resource=MegaBot2.0
    1\password=SUPER_SECRET_SECRET_PASSWORD
    1\conferenceHost=conference.example.com
    1\rooms\size=1
    1\rooms\1\roomName=ExampleRoom
    1\rooms\1\nickName=MegaBot2.0
    1\rooms\1\password=

    [Users]
    MegaBotUser=SUPER_SECRET_SECRET_PASSWORD

    ------------------>>> CUT HERE <<<--------------------

    WARNING: at this time all passwords are stored as PLAIN TEXT in the config
	file. They may be stored in other formats in the future but for now
	plain-text is the only option.

    Section [General]:
    $(INSTALLPATH) should be set to the directory where the 'megabot' binary and
    the 'scripts' directory reside.

    Section [Servers]:
    This section defines the list of servers the bot will connect to.

    Section [Users]:
    This section defines the list of users that can control the bot. This list has
    no relation to system users. Each entry in this section is in the form:

	$(USERNAME)=$(PASSWORD)

    You can also use the following command to generate an empty config file:

	megabot -w "~/.config/[LtK]Studios/MegaBot.conf"

------------------
3. Running the bot
------------------
    You can run the bot with the '-D' option to instruct the bot to run as a daemon.
    You can run the bot with the '-C' option to have it remain attached to the
    controlling terminal.

    When ran with the '-D' option (as a daemon) the bot will direct all logging
    information to:

	 $(INSTALLPATH)/mblog.log

    When ran with the '-C' option the bot will direct all logging information to the
    terminal.

----------------------
4. Controlling the bot
----------------------
    Once the bot has connected to a server you can send it commands via private messages
    (either directly to the main JID or to one of its room JIDs).

    * login <username> <password> - logs in with the specified MegaBot user
    * logout - logs the current user out
    * join <nickname> <roomname> - joins a chat room
    * part <roomname> - leaves a chat room
    * autojoin <roomname> - toggles the AUTOJOIN flag on a chat room. Chat rooms that have
	their AUTOJOIN flag set to ON are saved to the config file and are automatically
	joined when the bot is started again.
    * runscript <room> <script> - runs the specified script in the specified room.
	<script> is the base file name (without path) of the script to run. See the
	'Scripting' section below for more information.
    * stopscript <room> <script> - stops the specified script running in the specified room
    * autorun <room> <script> - toggles the AUTORUN flag on the specified room+script combo.
	Scripts that have their AUTORUN flag set to ON are saved to the config file and are
	automatically ran when the bot joins that chat room again.
    * say <room> <message> - does what it says
    * quit - causes the bot to exit

------------
5. Scripting
------------
    Scripts reside in the $(INSTALLPATH)/scripts directory. They are referenced by their base
    file name (file name without path information). A log file is automatically created for
    each running script. The path of the log file is $(INSTALLPATH)/scripts/$(SCRIPTNAME).log

    Scripts are only meant to process char room events. They can not control the bot in any
    way. Each script defines handler functions for the various chat room event types. These
    functions are then called by MegaBot whenever their corresponding even is detected. It
    is imperrative that these functions do NOT block. Blocking will cause the script to
    deadlock.

    The bot is designed to run scripts written in various scripting languages. See the sections
    below for information specific to each supported language.

--------------------
5.1 Scripting in Lua
--------------------
    The following functions must be defined by scripts:

      * function handle_room_config( config )
	This function is called whenever room configuration changes. In particular this is
	called immediatelly after the bot has joined a room. The 'config' parameter is a
	Lua table with the following fields:
	  - 'roomName': the name of the chatroom this script is running in
	  - 'roomJid' : the full JID of the chatroom this script is running in
			(roomName@conferencehost)
	  - 'nickName': the nickname the bot is using in this chatroom

      * function handle_room_message( message )
	This function is called whenever a room message is received. It will NOT be called for
	messages that have been sent by the bot itself (to avoid loops). The 'message' parameter
	is a Lua table with the following fields:
	  - 'nickName': the nickname of the sender of the message
	  - 'from'    : the full room JID of the sender of the message
			(room@conferencehost/nickName)
	  - 'body'    : the message body

      * function handle_room_presence( presence )
	This function is called whenever a chat room participant's presence changes. This is also
	called for presence changes for the bot itself. The 'presence' parameter is a Lua table
	with the following fields:
	  - 'who'     : the full room JID for the entity this event refers to
			(room@conferencehost/nickName)
	  - 'nickName': the nickname of the entity this event refers to
	  - 'presence': the current presence of the entity this event refers to. A value of
		  PRES_Available signals that the entity has just joined the chat room. A
		  value of PRES_Unavailable signals that the entity has just left the chat room.
	  - 'statusType': the current status type. Will be one of:
	          STAT_Offline
	          STAT_Online
	          STAT_Away
	          STAT_XA (extended away)
	          STAT_DND
	          STAT_Chat
	          STAT_Invisible
	   - 'statusText': the status text set by the user
	   - 'statusPriority': the priority of the presence

    The following functions are available from Lua code:

      * Table get_participants()
	Returns a list of all participants currently present in the chatroom.

      * (noreturn) send_room_message( message )
	Sends 'message' to the chat room.

      * (noreturn) dout( message )
	Outputs 'message' to the script-specific log file.

      * (noreturn) network_request( [name,] url )
        Starts an asynchronous network request (GET) on 'url'. The optional parameter 'name' can
	be used by scripts as an identifier for the request. If 'name' is not specified a random
	name is assigned to the request. If this function is used you MUST define the special
	reply handling function 'handle_network_reply()' (see below for details). Failure to do
	so will raise an error and will lead to the script being terminated.

	* function handle_network_reply( reply )
          this function is called whenever an asynchronous network reply finished, either normally
	  or due to an error. The 'reply' parameter is a Lua table with the following fields:
	    - 'status': will be set to 'true' (boolean) if the request was successfully completed,
	                or to 'false' if an error occured.
	    - 'data'  : if 'status' is true then this field contains the data that was fetched from
	                the url. If 'status' is false then this field contains an error message
			describing the error that occured
	    - 'name'  : specifies the name of the asynchronous request that generated the event
	    - 'url'   : specifies the URL of the request

	NOTE: URLs must be fully qualified
	      (eg protocol://[username[:password]@]some.host[:port][/some/path][?params])
	      The protocols that are supported depend on the capabilities of the underlying Qt
	      library. In general it is safe to assume that at least HTTP, HTTPS and FTP are
	      supported.
	NOTE: a limited number of network requests can be started at the same time. The default
	      limit is 10. You can change this value at compile-time by modifying the value of
	      MB_MAX_NETREQ_COUNT in megabot/cscriptrunner.h


      * (noreturn) set_timer( [name,] timeout )
        Create a new timer object that will activate after 'timeout' miliseconds have elapsed
        by calling the special handling function 'handle_timer_event()' (see below for details).
	The optional parameter 'name' can be used by scripts as an identifier for the timer.
	If 'name' is not specified a random name is assigned to the timer.

	* function handler_timer_event( timer_name )
	  This function is called whenever a timer ticks. 'timer_name' is a string that
	  represents the timer object that generated this event.

	NOTE: timers are 'single-shot'. This means that once a timer ticks it becomes inactive.
	      Scripts can re-arm the timer by calling set_timer() from handle_timer_event().
	NOTE: a limited number of timers can be started at the same time. The default limit is
	      set to 10. You can change this value at compile-time by modifying the value of
	      MB_MAX_TIMER_COUNT in megabot/cscriptrunner.h
